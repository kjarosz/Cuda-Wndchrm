==============================================================================
CUDA UDAT
Software documentation
------------------------------------------------------------------------------
Lawrence Technological University
Spring 2016 - Senior Project / Collaborative Research Project
Authors:
  Kamil Jarosz           <kjarosz@ltu.edu>
  Christopher K. Horton  <chorton@ltu.edu>
  Tyler Wiersing         <twiersing@ltu.edu>
==============================================================================

=== SECTIONS ===

1. License
2. About the algorithms
   2.1 Multiscale histogram
   2.2 Haralick
   2.3 Zernicke
3. Getting the code
4. Compilation
   4.1 Prerequisites
   4.2 Compiling the code
5. Using the code

=== 1. LICENSE ===

This software is covered under the terms of the MIT license. Please see
LICENSE.txt for more information.


=== 2. ABOUT THE ALGORITHMS ===

The algorithms in this project are CUDA-enabled versions of those from the
original UDAT image analysis software supplied to us by Dr. Lior Shamir at
Lawrence Technological University in Southfield, MI. Many of these algorithms
are described in a paper on the Wndchrm software here:
http://scfbm.biomedcentral.com/articles/10.1186/1751-0473-3-13

So far, the project contains code for the following algorithms modified to use
CUDA:

  - Zernicke
  - Haralick
  - Multi-scale histograms

Some of the other algorithms which still need to be converted include:

  - Gabor texture features
  - Tamura texture features

--- 2.1. MULTISCALE HISTOGRAM ---

Signature:

void CUDASignatures::compute_histogram_on_cuda(pix_data **images,
                                               int *widths,
                                               int *heights,
                                               int *depths,
                                               double *outputs,
                                               long *sizes,
                                               int *bits)

Usage:

Accepts CUDA-allocated variables of cPixels, cWidths, cHeights, cDepths,
cOutputs, cSizes, and cBits.

  - cPixels is an array of pixel_data for each image to be processed.
  - cWidths is an array of ints containing image widths for each image to be
    processed.
  - cHeights is an array of ints containing image heights for each image to be
    processed.
  - cDepths is an array of ints containing image depths for each image to be
    processed.
  - cOutputs is the output array of doubles for each image. This will be
    populated by the function for each image and will include the histogram
    data for intensity of the pixels in the images.
  - cSizes is an array of long type containing the size of the images.
  - cBits is an array of ints containing the bit size of the images.

This function launches the kernel which will run the function:

__device__
void multiscalehistogram(pix_data *data,
                         double *out,
                         int *width,
                         int *height,
                         int *depth,
                         int *bits)

This accepts all of the same variables that the compute_histogram_on_cuda
accepts.

This function will run through each set of pixel data passed to it and run the
function:

__device__
void histogram(pix_data *data,
               double *bins,
               unsigned short bins_num,
               int imhist,
               int *width,
               int *height,
               int *depth,
               int *bits)

This function accepts:

  - data: An array of pix_data.
  - bins: An array of doubles which are temporary containers for the histogram
          data.
  - bins_num: A number which denotes which bin the histogram data should be
              populated into.
  - imhist: An int denoting whether or not a min and max intensity value
            should be calculated before running the histogram calculation.
  - width: Same as cWidth.
  - height: Same as cHeight.
  - depth: Same as cDepth.
  - bits: Same as cBits.

This function will loop through all of the pixels and find the min and max
intensity. It will then allocate the remaining pixels into a histogram which
shows the count of pixels with the same intensity.

After the function returns, compute_histogram_on_cuda will take the histogram
values placed into the cOutputs variable into the output file generated by the
program.

--- 2.2. HARALICK ---

Signatures:

compute_haarlick_on_cuda(cPixels, cWidths, cHeights, cDepths, cOutputs, cSizes,
                         cBits);
haarlick(pix_data *pixels, double *distance, double *out, int *height,
         int *width, int *depth, unsigned short int *bits);
BasicStatistics(pix_data *color_data, double *min, double *max, int bins,
                int num_pixels);
Extract_Texture_Features(int distance, int angle, register u_int8_t **grays,
                         int rows, int cols, int max_val);

Usage:

Accepts CUDA-allocated variables of cPixels, cWidths, cHeights, cDepths,
cOutputs, cSizes, and cBits.

  - cPixels is an array of pixel_data for each image to be processed.
  - cWidths is an array of ints containing image widths for each image to be
    processed.
  - cHeights is an array of ints containing image heights for each image to be
    processed.
  - cDepths is an array of ints containing image depths for each image to be
    processed.
  - cOutputs is the output array of doubles for each image. This will be
    populated by the function for each image and will include the data for:
      - Angular Second Moment
      - Contrast
      - Correlation
      - Variance
      - Inverse Difference Moment
      - Sum Average
      - Sum Variance
      - Sum Entropy
      - Entropy
      - Difference Variance
      - Difference Entropy
      - Measure of Correlation 1
      - Measure of Correlation 2
      - Max Correlation Coefficient
    Information on these functions are available here:
    http://murphylab.web.cmu.edu/publications/boland/boland_node26.html
  - cSizes is an array of long type containing the size of the images.
  - cBits is an array of ints containing the bit size of the images.

This function calls:

haarlick

This function accepts:
  - pixels: Same as cPixels
  - distance: A global variable declared in compute_haarlick_on_cuda, set to 0.
  - out: Same as cOutputs.
  - height: Same as cHeights.
  - width: Same as cWidths.
  - depth: Same as cDepths.
  - bits: Same as cBits.

This is the main Haarlick function which actually performs the calculations.
First it calls:

BasicStatistics

which accepts:

  - color_data: Same as cPixels.
  - min: An array of doubles.
  - max: An array of doubles.
  - bins: An int, set to 0 always.
  - num_pixels: An int which is set to the amount of pixels in the image
    (height*width*depth).

This function will return the average min/max intensity values of the images
in the arrays of min and max.

The haarlick function will now call the:

ExtractTextureFeatures

function which computes the values listed above (Angular Second Moment,
Contrast, Correlation, etc.).

After these values are computed and set, the out variable is populated with
the calculated values and the function ends. The compute_haarlick_on_cuda
function will now place the values placed into out into the output file that
the program generates.

--- 2.3. ZERNICKE ---

Signatures:

void CUDASignatures::compute_zernike_on_cuda(pix_data **images, int *widths,
                                             int *heights, int *depths,
                                             double *outputs, long *sizes)
__global__ void zernike(pix_data **images, int *widths, int *heights,
                        int *depths, double *d, double *r, double *zvalues,
                        long *output_size);
__device__ void znl(long n, long l, double *X, double *Y, double *P, int size,
                    double *out_r, double *out_i);
__device__ double image_moments(pix_data *image, int width, int height, int x,
                                int y);

Usage:

Accepts CUDA-allocated variables of images, widths, heights, depths, outputs,
and sizes.

  - images is an array of pixel_data for each image to be processed.
  - widths is an array of ints containing image widths for each image to be
    processed.
  - heights is an array of ints containing image heights for each image to be
    processed.
  - depths is an array of ints containing image depths for each image to be
    processed.
  - outputs is the output array of doubles populated by the function for each
    image.
  - sizes is an array of longs.

This function in turn calls the zernike function, with the following inputs:

  - images: Same as images above.
  - widths: Same as widths above.
  - heights: Same as heights above.
  - depths: Same as depths above.
  - d: An array of doubles.
  - r: An array of doubles. This represents the maximum radii to use for each
       image.
  - z_values: An array of doubles.
  - output_size: An array of longs.

This function in turn calls the znl function, which is what generates Zernicke
moments, with the following inputs:

  - n: A long indicating the degree of the moment.
  - l: A long indicating the angular dependence.
  - X: An array of doubles. One of the coordinate vectors.
  - Y: An array of doubles. One of the coordinate vectors.
  - P: An array of doubles. This is the intensity vector.
    - Note that X, Y, and P must all be of the same length.
  - size: An int. This is the length of each of the X, Y, and P arrays.
  - out_r: An array of doubles. This is the real portion of the "returned"
           values.
  - out_i: An array of doubles. This is the imaginary portion of the "returned"
           values.

The zernike function also calls the image_moments function a few times, which
calculates the moment for each image with the following inputs:

  - image: One of the pix_data instances from the images variable above.
  - width: The corresponding value from the widths variable.
  - height: The corresponding value from the heights variable.
  - x: An int.
  - y: An int.

The zernike function's moment10, moment00, and moment01 variables are each
generated using this function. This is done to normalize the coordinates to
the center of mass and normalize pixel distances using the maximum radius.

More information on the Zernicke algorithm itself can be found here:
http://murphylab.web.cmu.edu/publications/boland/boland_node25.html


=== 3. COMPILATION ===

CUDA UDAT is currently hosted on GitHub in source form here:
https://github.com/kjarosz/new_cuda_udat

If you are using Git with a command line interface or terminal, you can simply
run the following command to get the latest version of the main code branch:

git clone https://github.com/kjarosz/new_cuda_udat.git


=== 4. COMPILATION ===

--- 4.1 PREREQUISITES ---

After you have obtained the CUDA UDAT source code, you will need to make sure
you also have the following installed:

  - Microsoft Visual Studio 2013*
  - NVIDIA's CUDA Toolkit
    - This is currently available at https://developer.nvidia.com/cuda-toolkit

* Note: The version of Visual Studio you use is important, since NVIDIA
currently does not support any newer versions like 2015 with their CUDA
Toolkit yet.

You will need to be using a Windows PC with an NVIDIA graphics card with CUDA
technology. We have not tried compiling or running our code on any other
operating system or IDE, and currently have no plans to do so nor support such
alternative setups.

--- 4.2 COMPILING THE CODE ---
The Visual Studio project is already prepared and ready to compile. Simply go
into the Build menu and hit Build Solution, and the code will be compiled.


=== 5. USING THE CODE ===

The application accepts only one argument and it is the directory containing
the classes of images. The folder structure expected consists of a root
directory and multiple folders for each class of images. The images will have
to be placed into the class directories, otherwise they will not be read. The
output of the application will be saved in the root directory.


=== 6. FEEDBACK ===

Bugs, questions, and other feedback may be submitted to the authors of this
software here:

https://github.com/kjarosz/new_cuda_udat/issues/new
